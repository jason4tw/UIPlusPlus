// XHTMLCtrl.h  Version 2.5
//
// Author:  Hans Dietrich
//          hdietrich@gmail.com
//
// License:
//     This file is Copyright © 2011 Hans Dietrich. All Rights Reserved.
//
//     This source file is the property of Hans Dietrich and is not to be
//     re-distributed by any means whatsoever without the expressed written
//     consent of Hans Dietrich.
//
//     This source code can only be used under the Terms of Use set forth
//     on the Hans Dietrich Software web site. Hans Dietrich Software grants 
//     to you (one software developer) the limited right to use this software.
//
//     This software is provided "as is" with no expressed or implied warranty.
//     Hans Dietrich accepts no liability for any damage or loss of business 
//     that this software may cause.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef XHTMLCTRL_H
#define XHTMLCTRL_H


//=============================================================================
// NOTE ABOUT PRECOMPILED HEADERS
//
// If you are using this control in a non-MFC project, XHTMLCtrl.cpp does not 
// need to be compiled with precompiled headers (.pch).  To disable this, go  
// to Project | Settings | C/C++ | Precompiled Headers and select "Not using 
// precompiled headers".  Be sure to do this for all build configurations.
//
// If you want to use this control in an MFC project, un-comment the next line,
// and include stdafx.h in XHTMLCtrl.cpp. This will cause the standard MFC 
// classes to be used and reduce the memory footprint of the control.  

#define XHTMLCTRL_USE_MFC


#ifdef XHTMLCTRL_USE_MFC
	#define CWTLString		CString
	#define CXToolTipCtrl	CToolTipCtrl
	#define CXRect			CRect
	#define CXPoint			CPoint
#else
	#include "wtlstring.h"			// string class from WTL
	#include "CXToolTipCtrl.h"		// non-MFC tooltip class
	#include "CXRect.h"				// non-MFC rect class
	#include "CXPoint.h"			// non-MFC point class
#endif // XHTMLCTRL_USE_MFC


#include "xarray.h"
#include "xstack.h"

namespace HansDietrich {
	//=============================================================================
	struct XHTMLCTRL_APP_COMMAND
		//=============================================================================
	{
		HWND	hWnd;			// HWND of window to receive message
		UINT	uMessage;		// message sent to parent
		WPARAM	wParam;			// user defined data returned in wParam parameter
		TCHAR *	pszCommand;		// string that ties this entry to HTML hyperlink
	};

	//=============================================================================
	struct XHTMLCTRL_CHAR_ENTITIES
		//=============================================================================
	{
		const TCHAR *	pszName;		// string entered in HTML - e.g., "&nbsp;"
		TCHAR	cCode;			// code generated by XHTMLCtrl
		TCHAR	cSymbol;		// character symbol displayed
	};

	//=============================================================================
	class CXHTMLCtrl
		//=============================================================================
	{
		// Construction
	public:
		CXHTMLCtrl();
		virtual ~CXHTMLCtrl();
		void ResetAll();			// formerly called Init()
		void Reset();

		// Attributes
	public:
		HWND m_hWnd;
		HWND m_hParent;
		UINT m_nId;
#ifdef XHTMLCTRL_USE_MFC
		CWnd m_CWnd;
#endif

		// this is the first image control id;  subsequent ids are
		// incremented by one
		enum { XHTML_FIRST_IMAGE_CONTROL_ID = 7001 };

		UINT GetImageControlId() { return m_nNextImageControlId; }
		CXHTMLCtrl& SetImageControlId(UINT nId) { m_nNextImageControlId = nId; return *this; }

		COLORREF GetBkColor(int index = -1) const;
		virtual CXHTMLCtrl& SetBkColor(COLORREF rgb, int index = -1);
		virtual CXHTMLCtrl& SetBkColor(LPCTSTR lpszColor, int index = -1);
		virtual CXHTMLCtrl& SetAllBkColor(COLORREF rgb);
		virtual CXHTMLCtrl& SetAllBkColor(LPCTSTR lpszColor);

		COLORREF GetTextColor(int index = -1) const;
		virtual CXHTMLCtrl& SetTextColor(COLORREF rgb, int index = -1);
		virtual CXHTMLCtrl& SetTextColor(LPCTSTR lpszColor, int index = -1);
		virtual CXHTMLCtrl& SetAllTextColor(COLORREF rgb);
		virtual CXHTMLCtrl& SetAllTextColor(LPCTSTR lpszColor);

		LOGFONT& GetLogFont(int index = -1);
		CXHTMLCtrl& SetLogFont(const LOGFONT& lf, int index = -1);

		static int GetFontHeight(int nPointSize);
		static int GetFontPointSize(int nHeight);
		CXHTMLCtrl& SetFontHeight(int nHeight, int index = -1);
		CXHTMLCtrl& SetFontPointSize(int nPointSize, int index = -1);

		CXHTMLCtrl& SetMargins(int nLeftMargin, int nRightMargin)
		{
			m_nLeftMargin = nLeftMargin;
			m_nRightMargin = nRightMargin;
			return *this;
		}
		CXHTMLCtrl& SetAppCommands(XHTMLCTRL_APP_COMMAND * paAppCommands, int nAppCommands);
		CXHTMLCtrl& EnableTooltip(BOOL bFlag)
		{
			m_bToolTip = bFlag;
			return *this;
		}
		BOOL IsTooltipEnabled() const
		{
			return m_bToolTip;
		}

		void GetWindowRect(LPRECT lpRect);
		void MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE);
		CWTLString GetWindowText() { return m_strText; }
		CXHTMLCtrl& SetWindowText(LPCTSTR lpszString);
		CWTLString GetTitleText() { return m_strTitleText; }	//+++2.4
		BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);
		BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL, HRGN hrgnUpdate = NULL,
			UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
		BOOL UpdateWindow();
		BOOL Invalidate(BOOL bErase = TRUE);
		BOOL ShowWindow(int nCmdShow);


		// Overrides
	public:
		virtual BOOL Create(HINSTANCE hInstance, HINSTANCE hResourceInstance,	//+++2.5
			DWORD dwStyle, const RECT& rect, HWND hParent, UINT nID);
		virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

		// Implementation
	protected:
		int		AddImageWindow(HWND hwnd, UINT nToolId, RECT& rect);
		void	CleanupImageWindows();
		void	ClientToScreen(RECT *pRect);
		int		CountImageTags(LPCTSTR lpszString);
		void	DisplayImageTooltip(POINT point);
		void	Draw(HDC hdc);
		int		FindActiveImageWindow(POINT point);
		int		FormatText(HDC hdc, LPCTSTR lpszText, RECT * pRect, int nInitialXOffset, BOOL *pbCharEntityFound);
		TCHAR	GetCharEntity(TCHAR cCode);
		SIZE	GetCursorOffset(HWND hWnd);
		CWTLString	GetNextWord(TCHAR **ppText, BOOL *pbReturnSeen, BOOL *pbCharEntityFound);
		LONG	GetRegKey(HKEY key, LPCTSTR subkey, LPTSTR retdata);
		void	GetSafeFont(LOGFONT& lf);
		BOOL	GotoURL(LPCTSTR url, int showcmd);
		void	InitCharEntities();
		void	InitControl();
		BOOL	IsBlank(LPCTSTR lpszText);
		BOOL	KillTimer(UINT nIDEvent);
		void	OnTimer(UINT nIDEvent);
		BOOL	ProcessAppCommand(LPCTSTR lpszCommand);
		void	SetHyperlinkCursor();
		UINT	SetTimer(UINT nIDEvent,
			UINT nElapse,
			TIMERPROC lpTimerFunc);

		HINSTANCE		m_hResourceInstance;								//+++2.5
		HDC				m_hMemDC;
		HBITMAP			m_hBitmap;
		HBITMAP			m_hOldBitmap;
		CXToolTipCtrl	m_ToolTip;
		BOOL			m_bRefresh;
		BOOL			m_bToolTip;
		BOOL			m_bCenter;
		BOOL			m_bInHtml;					// TRUE if <html> tag seen	//+++2.4
		BOOL			m_bInBody;					// TRUE if <body> tag seen	//+++2.4
		BOOL			m_bHorizontalRule;
		BOOL			m_bGeneratedText;
		BOOL			m_bInAnchor;
		BOOL			m_bOnHyperlink;
		BOOL			m_bTracking;				// TRUE = in control rect
		int				m_nImageTooltipActive;
		int				m_nHorizontalRuleSize;
		int				m_nInitialDelay;
		int				m_nAutoPop;
		int				m_nImages;
		int				m_nLeftMargin, m_nRightMargin;
		int				m_yStart;
		int				m_nAppCommands;
		static UINT		m_nNextImageControlId;
		HCURSOR			m_hLinkCursor;
		HCURSOR			m_hPrevCursor;
		SIZE			m_sizeCursor;
		SIZE			m_sizeLeftIndent;
		SIZE			m_sizeRightIndent;
		CXRect			m_rectCtrl;
		CXPoint			m_prevPoint;
		CWTLString		m_strText;
		CWTLString		m_strTitleText;				// text from <title>		//+++2.4
		static XHTMLCTRL_CHAR_ENTITIES	m_aCharEntities[];
		XHTMLCTRL_APP_COMMAND *			m_paAppCommands;

#define XHTMLCTRL_MAX_URL 2048

		struct XHTMLCTRL_ANCHOR_INFO
		{
			XHTMLCTRL_ANCHOR_INFO()
			{
				SetRectEmpty(&rect);
				szUrl[0] = 0;
			}
			RECT	rect;
			TCHAR	szUrl[XHTMLCTRL_MAX_URL];
		};
		XArray<XHTMLCTRL_ANCHOR_INFO> m_AnchorInfo;

		struct XHTMLCTRL_IMAGE_INFO
		{
			HWND		hwnd;		// hwnd returned by DisplayImage()
			RECT		rect;		// image rect, client coords
			UINT		id;			// tooltip id; 0 = no tooltip
		};
		XHTMLCTRL_IMAGE_INFO *	m_pImageInfo;

		struct XHTMLCTRL_FONT_INFO
		{
			XHTMLCTRL_FONT_INFO()
			{
				Reset();
			}
			void Reset()
			{
				memset(&lf, 0, sizeof(lf));
				crText = GetSysColor(COLOR_WINDOWTEXT);
				crBackground = GetSysColor(COLOR_WINDOW);
				nBaseLineAdjust = 0;
			}
			LOGFONT		lf;
			COLORREF	crText;
			COLORREF	crBackground;
			int			nBaseLineAdjust;
		};

		XHTMLCTRL_FONT_INFO m_CurrentFontInfo;
		XHTMLCTRL_FONT_INFO m_HeaderFontInfo[6];
		XStack<XHTMLCTRL_FONT_INFO> m_FontInfo;
	};
}
/////////////////////////////////////////////////////////////////////////////

#endif //XHTMLCTRL_H
